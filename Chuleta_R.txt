-BASIC BUILDING BLOCKS-
c() me sirve para crear vectores, tener en cuenta q un numero solo ya se interpreta como un vector de longitud 1.
si p.ej me creo un vector z y luego hago 2*z multiplica todos los elem del vector por ese 2.

sqrt()==square root//raiz cuadrada
abs()==valor absoluto

Si cojo 2 vectores del mismo tam, y le aplico una operacion (x+y, x e y vectores) le aplica la operacion elemento a elemento. OJO, si el hay un vector mas pequeño, r aplica reciclaje del vector, p.ej a<-(1, 2, 3) y hago 2+a, realmente haria c(2, 2, 2)+c(1, 2, 3)

-WORKSPACE AND FILES-
para ver mi directorio de trabajo-> getwd()
cambiarlo-> setwd()
para listar objetos de mi workspace-> ls()
list.files() seria igual q el ls de linux
con args() puedo ver los argumentos q necesita mi funcion
dir.create() == mkdir
file.create() -> para crear nuevos ficheros R
file.remove() -> borrarlos
file.exists() -> para ver si el fichero existe
file.info() -> para ver la info del fichero
IMPORTANTE el op $ me sirve para pillar elementos sueltos del fichero
file.rename(aaa, bbb) -> renombrar
file.copy() -> copiar fichero

dir.create()->crea directorios
dir.create(file.path("testdir2", "testdir3"), recursive = TRUE) -> crearia los 2 directorios anidados esos en mi esp de trabajo actual. 

-SEQUENCE OF NUMBERS-
ej de sec facil 1:5
tmb se puede hacer con seq() pero ya hace + cosas
seq(0, 10, by=0.5) hace una secuencia pero incrementa de 0.5 en 0.5
seq(0, 10, length=30) lo mismo, una secuencia, pero quiero q tenga 30 valores dif entre 0 y 10
length() igual q en java, devuelve el tamaño de la cadena
1:length(my_seq) == seq(along.with = my_seq) == > seq(along.with = my_seq)
rep() == replicate
-> rep(0, times=40)
-> rep(c(0, 1, 2), times=10)
-> rep(c(0, 1, 2), each=10)

-VECTORS-
vectores logicos=3 valores true, false y NA (not available).
paste -> pegar el contenido de un vector en una unica cadena.
si hago paste con 2 vectores de tam diferente haria lo de 
c( , ) -> me sirve para concatenar 2 vectores, no confundir con c() q es el de crear el vector.

-MISSING VALUES-
todo lo que sea NA, si lo opero de cualquier form me tiene q devolver NA.
sample( , x) me deja pillar una muestra de tam x de un vector
is.na() me sirve para ver si cada valor es o no un NA (devolveria true o false).
NaN == not a number (p ej 0/0 o Inf-Inf)

-SUBSETTING VECTORS-
extraer elementos de un vector en base a condiciones
x[1:10] -> me sirve para ver las 10 primeras entradas del vector
x[is.na(x)] -> devuelve un vector con los na de mi vector
x[!is.na(x)] -> devuelve un vector sin los na de mi vector
OJO->r usa el 'one-base index' que implica que el primer elemento del vector es la posicion 1, en c y demas el primero es 0.
> x[c(3,5,7)] posiciones 3,5,7 del vector x
x[c(-2,-10)]==x[-c(2,10)] me da todo menos las pos 2 y 10
vect <- c(foo=11, bar=2, norf=NA)
names(vect) sacaria foo bar y norf
vect2 <- c(11,2,NA) & names(vect2) <- c("foo", "bar", "norf") hace lo mismo q arriba pero en mas pasos
identical(x,y) true si son iguales, false si no
vect["bar"] me sacaria el contenido de bar


#CREAR Y VISUALIZAR DATAFRAME EN CONSOLA R

> nombres<-c("Sonia", "Ana", "Mario")
> edades<-c(20, 21, 19)
> ciudad_origen<-c("Ourense", "A Coruña", "Arteixo")
> conj_datos<-data.frame(Nombres=nombres, Edades=edades, Ciudad_origen=ciudad_origen)
> summary(conj_datos)

https://anderfernandez.com/blog/regresion-lineal-r/

#GUARDAR EL DATAFRAME: save(conj_datos, file="ConjDatos.RData")
> Ojo, si luego lo quiero cargar y mostrar seria: load("ConjDatos.RData") y View(conj_datos)

#PARA HACER LAS COMBINACIONES: choose(n, k)
lapply() aplica una funcion a cada elemento de un vector
mapply() lo mismo, pero permite aplicarla a varios vectores a la vez
